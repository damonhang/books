# 设计模式阅读笔记
## 设计原则
### 单一职责原则
**应该有且仅有一个原因引起类的变更**
::抽象级别隔离、不同抽象隔离::
### 里氏替换原则
**所有引用几类的地方必须能够透明的使用起子类的对象**
* 子类必须完全实现基类的方法
::父类的所有方法在子类中都要有同样的目标/作用(不管具体逻辑，满足方法名指定的action)::
* 子类可以拥有子类的个性
::子类的个性应该指另外的方法/行为和对用父类方法的不同实现::
* 覆盖或实现父类的方法时输入参数可以被放大
* 复写或实现父类的方法时输出参数可以被缩小
### 依赖倒置原则
* 高层模块不应该依赖底层模块，两者都应该依赖其抽象
* 抽象不应该依赖细节
* 细节应该依赖抽象
### 接口隔离原则
* 客户端不应该依赖他不需要的接口
::接口尽量细化(单一职责)，接口中的方法尽量少::
* 类间的依赖应该建立在最小的接口上
::面向接口编程的精髓，类的实现可能从不同角色可以抽象出不同的抽象(接口),其他类应该依赖他最契合的接口，即·最小满足接口·::
### 迪米特法则
一个对象应该对其他的对象有最少的了解
* 高内聚、低耦合
* 只和朋友说话
* 如果一个方法放在本类中几部增加类间关系也不对本类造成影响，那就放置在本类中
### 开闭原则
一个软件实体：如类、模块、函数应该对扩展开发，对修改关闭
## 设计模式
### 怎样解决设计问题
**形构**：对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是操作的形构
给对象发送请求时，所引起的具体操作，即与发送的请求有关，又与接受对象有关，支持相同请求的不同对象可能对激发的操作有不同实现，发送给对象的请求和它的相应操作在运行时的连接就称为**动态绑定**
**多态**：动态绑定允许你在运行时刻彼此替换有相同接口的对象，这种可替换性就称为多态
**针对接口编程，而不是针对实现编程**
### 运用复用机制
#### 继承和组合的比较
继承：白箱复用、组合：黑箱复用
**优先使用对象组合而不是继承**
#### 委托
委托是对象组合的特例，他告诉你对象组合做作为一个代码复用机制可以代理继承
#### 设计应支持变化
* 不应该显示指定一个类来创建对象
* 不应该依赖特定操作
* 不应该依赖硬件和软件平台
* 不要依赖对象表示和实现
* 不要依赖算法
* 不应该紧耦合
* 不应该通过生成子类来扩展功能
* 需要方便的对类进行修改
## 设计模式编目
### 分类
**创建型** 与对象的创建有关
**结构性** 处理类和对象的组合
**行为型** 对类或对象怎么交互怎样分配职责进行描述
**类模式** 处理类和子类之间的关系，这些关系通过继承建立，是静态的
**对象模式** 处理对象间的关系，关系在运行时是可以变化的，具有动态性
![](./../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/5A920F27-D7E1-4730-A593-68980E77C2A6.png)
### 编目
**粗体**为运用不熟练 **斜体**为较为熟练但偶尔理解有问题 ~下划线~ 为能正常使用， ~~删除线~~ 为熟练使用
* **抽象工厂** 提供创建一系列相关或者相互依赖对象的接口，无需指定他们具体的类
* *适配器* 将一个类的接口转换成客户希望的另外一个接口，使得原本由于不兼容的而不能一起工作的那些类可以一起工作
* **桥接** 将抽象与他的实现部分分离，使他们都可以独立的变化
* ~builder~ 将一个复杂对象的构建与他的表示分离，使得同样的创建过程可以创建不同的表示
* ~~责任链~~ 接触请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求，将这些对象连成一条链，直到有一个对象处理它
* *命令模式* 讲一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化
* **Composite** 将对象组合成树形结构以表示整体-部分的层次结构，是的客户对当个对象和符合对象的使用具有一致性
* **装饰器** 动态的给一些对象添加一些额外的职责，就扩展功能而言，比子类方式更灵活  
> 代理模式和装饰器模式的区别:代理模式，注重对对象某一功能的流程把控和辅助。它可以控制对象做某些事，**重心是为了借用对象的功能完成某一流程，而非对象功能如何。**  
> 装饰模式，注重对对象功能的扩展，**它不关心外界如何调用，只注重对对象功能的加强，装饰后还是对象本身。**  
> **对于代理类，如何调用对象的某一功能是思考重点，而不需要兼顾对象的所有功能；**  
> **对于装饰类，如何扩展对象的某一功能是思考重点，同时也需要兼顾对象的其它功能，因为再怎么装饰，本质也是对象本身，要担负起对象应有的职责**  
>
> * ~facade模式~ 为系统中的一组接口提供一个一致的界面，定义一个高层接口，使这子系统更容易使用  
* **factory method模式** 定义一个用于创建对象的接口，让子类决定将哪一个类实例化，使一个类的实例化延迟到子类 *类似于FactoryBean模式*
* ~flyweight(享元)模式~ 运用共享技术有效的支持大量细粒度的对象
* **interpreter解释器模式**  给定一个语言，定义他的文法的一种表示，并定义一个解释器，改解释器使用该表示来解释语言中额句子
* ~~迭代器模式~~ 提供一种顺序访问一个聚合对象中的各个元素而又不暴露该对象的内部表示
* **Mediator中介者模式** 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式的相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互
> 觉得和flux流的模式有些像  
* *Memento备忘录模式* 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。以后可以将该对象恢复到原先保存的状态
* ~Observer观察者模式~ 即**发布订阅模式** 定义对象间的一种1对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
* ~~prototype原型模式~~ 用原型实例指定创建对象的种类,并且通过拷贝这个原型链接来创建新的对象
* ~~Proxy代理模式~~ 为其他对象提供一个代理，以控制对这个对象的访问
* ~~Singleton单例模式~~ 保证一个类仅有一个实例
* **State** 状态模式 允许一个对象在其内部状态改变时改变他的行为，对象看起来似乎修改了它的所属类
* ~~策略模式~~ 定义一系列算法，把它们一个一个封装起来，并且使它们可以相互替换
* ~~模板方法~~ 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中
* **visitor访问者模式** 表示一个作用于某对象结构中的各元素操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作

