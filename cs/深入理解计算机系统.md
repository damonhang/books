# 深入理解计算机系统
## 计算机系统漫游
### 信息就是位+上下文
8个位称为一个字节
编译过程
CPP(预处理器)->ccl(编译器、汇编代码)->as(汇编器、机器代码)-ld(链接器)
### 系统硬件组成
总线:传送固定长度的字节快 4位或8位字节，也就是我们常说的32/64位系统
I/O设备：通过适配器和控制器与总线相连
主存:DRAM芯片组成
处理器:寄存器(程序计数器)，按照指定的**指令集架**执行程序，执行指令的简单操作，这些操作围绕主存、**寄存器文件**、ALU(算术逻辑单元)组成::主要的操作包括:加载、存储、操作、跳转::
> 利用DMA(直接存储器存取)，数据可以不通过处理器而直接从磁盘到达主存  
### 高速缓存至关重要
寄存器>L1告诉缓存(SRAM)>L2高速缓存(SRAM)>L3高速缓存(SRAM)>主存(DRAM)>本地二级存储(磁盘)>远程二级存储(分布式文件系统)
::操作系统是应用程序和硬件之间的一层软件，所有应用程序对硬件的操作都必须都过操作系统,操作系统通过几个抽象概念,文件是对IO的抽象，虚拟内存是对主存和磁盘IO的抽象，进程则是对处理器、主存和IO的抽象::
### 进程
**进程是操作系统对一个正在运行的程序的一种抽象**
从一个进程到另一个进程的切换是由操作系统内核管理的，**内核**是操作系统常驻主存的部分，他不是一个独立的的进程，相反，他是系统管理全部进程所用代码和数据结构的集合
#### 虚拟内存
**虚拟内存**是一个抽象概念，它为每个进程提供一个假象，即每个进程都独占使用主存，每个进程看到的内存都是一致的，称为**虚拟地址空间**
##### 结构
程序代码和数据、堆、共享库、栈、内核虚拟内存
#### 文件
文件就是字节序列，仅此而已
### 系统间利用网络通信
系统从主存复制一串字节到网络适配器，数据流经过网络到达另外一台机器
### 重要主题
* Amdahl定律
#### 并发和并行
## 信息的表示和处理
**无符号**编码基于传统的二进制表示法
**补码**编码是表示有符号整数最常见的方式
**浮点数**编码是表示实数的科学计数法的以2位基数的版本想·xxxxx
可以通过man ascii生成一张ascii表
二进制代码很少能在不同的机器和操作系统组合之间进行移植
### 信息存储
1.使用8位的**块**或者字节作为最小的**可寻址内存单位**
2.机器级程序将内存视为一个非常大的字节数组(字节作为最小的可寻址单位)，称为**虚拟内存**，内存的每个字节都由唯一的数字表示，称为地址，所有地址的集合称为**虚拟地址空间**
#### 十六进制表示法
10进制与16进制的转换:
![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/91ADE78E-427B-4C05-BF0E-A10971EB886D.png)
#### 字数据大小
每台计算机都有一个**字长**，字长最重要的就是决定虚拟地址空间的最大大小
::ISO 99引入的int32_t int64t能保证在32位和64位系统中分配的固定的数据大小::
#### 寻址和字节顺序
在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址
**大端法**、**小端法**:两种有效字节的存储方式
小端法:最低有效字节在前面，大端法相反
![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/323F4E99-10F8-482B-A09D-7CF39C9FB54E.png)
**位移运算** 逻辑位移:在左端补k个0，算术位移:在k端补k个最高有效位的值 java中 >> 表示算术位移 >>>表示逻辑位移
### 整数表示
机器术语:
![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/B64C2AD1-EB78-47B5-82EA-8CD5A20E3785.png)

最常见的有符号数的计算机表达方式就是**补码**,将字的最高有效为解释为负权，最高有效为为1时标示负数，为0时，值非负
B2T表示法:B2Tw(X)=-X_w-12^w-1+∑_i=0^w-2 X_i 2^i
源码、反码、补码
无符号数的**零扩展**，要将一个无符号数转换为更大的类型，只要简单的在表示的开头添加0，要将一个补码数字转换为一个更大的数据类型，可以执行**符号扩展**，在标示中添加最高有效位的值
### 整数运算
##### 无符号数加法
![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/00625D73-6491-409B-A58F-E5A68B5D1762.png)
补码加法：
![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/1CC5530B-EE46-4B39-9035-75B77853E332.png)
无符号乘法:
![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/29E6A201-FEB8-4671-AAFB-FF031C3BC5AC.png)
补码乘法:
![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/DC2EE391-3647-4F26-B9E0-E5386330BECC.png)
整数乘法执行相当慢，在执行乘以常数时，会试着用移位和加法的组合来代替乘以常数因子的乘法，例如 x*14时，14=2^3+2^2+2^1,编译器会将乘法重写为:(x<<3)+(x<<2)+(x<<1)  或者(x<<4)-(x<<1)
**整数除法** 在大多数机器上，整数除法比乘法还要慢，也可以用移位运算来实现
### 浮点数
二进制位表示浮点数时 遵循表达式:
![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/E79BF458-C77B-4CBA-8683-580320DC8153.png)
,那么表示法只能表示那些能够被写成x*2^y的数，其他值只能被近似的表示，增加二进制表示的长度可以提高表示的精度
#### IEEE浮点表示
IEEE浮点标准用![](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/FBF01511-CA96-4EB9-A27B-93BC0524B2EA.png)来表示一个数 符号s决定是正数还是负数， 尾数M是一个二进制小数。阶码E的作用是对浮点进行加权，这个权重是2的E次幂(可能是负数)，
将位分为了三段:符号s,k位编码，n位小数
在32位的float中:s一位，k8位，n23位
分为:
规格化的值：阶码被解释为:E=e-bias    尾数定义为:M=1+f
非规格化值、无穷大、NAN
#### 浮点运算
浮点加法不具有结合性，因为舍入，浮点加法满足单调性，浮点乘法在加法上不具备分配性

## 程序的机器级表示
gcc C语言的编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示
### 程序编码
对于机器级编程来说，两种重要的抽象:
1.指令集体系结构和指令集架构定义机器级程序的格式和行为
2.虚拟内存地址，利用内存数组
常用的机器代码:
1. 程序计数器:给出将要执行的下一条指令在内存中的地址
2. 整数寄存器文件:包含16个命令的位置
3. 条件吗寄存器:保存着最近执行的算术或逻辑指令的状态信息，用来实现控制或数据流中的条件变化
4. 一组向量寄存器可以存放一组或者多个整数或者浮点数的值
程序内存包含:
程序可执行机器代码、操作系统需要的一些信息、用来管理过程调用和返回的运行时栈、以及用户分配的内存块
操作系统负责管理虚拟内存空间，将虚拟地址翻译成实际处理器内存中的物理地址
一条机器指令只执行一个非常基本的操作，例如:将存在寄存器中的两个数字相加，在存储器和寄存器中传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列从而实现程序结构
**机器执行的程序只是一个字节序列，他是对一系列指令的编码，机器对产生这些指令的程序几乎一无所知**
链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置
### 访问信息
#### 操作指示符
操作数可能的三种类型
1. 立即数:表示常数值
2. 寄存器:表示某个寄存器的内容
3. 内存引用，或根据计算出来的内存地址访问某个内存位置
#### 数据传送指令
mov指令类:吧数据从源位置复制到目的位置
局部变量通常是保存在寄存器中
技术所有的指令都有4种形式:单字节操作、单字操作、双字操作、4字操作
### 控制
除了整数寄存器，CPU还维护了一组单个位的条件码寄存器，他们描述最近的算术和逻辑操作的属性
标记指令:CMP和测试指令:TEST
**条件码**的三种常用使用方式:
1. 根据条件吗某种组合，将某个字节设置为0或者1 **SET指令**
2. 可以条件跳转到程序的某个蒂塔部分 **JUMP指令，跳转的目的地通常用一个标号(label)指明**
3. 可以有条件的传输数据
跳转分为直接跳转和间接跳转，直接跳转跳转到label，间接跳转跳转目标从寄存器(jmp *%rax)或者内存(jmp *(%rax),rax中存的内存的地址)中读出
#### 基于条件传送来实现条件分支
基于条件数据传送的数据要比基于条件控制转移的代码的性能要好
::现代处理器通过使用流水线来获得高性能，要求实现确定要执行的指令序列，这样才能保证流水线中充满了待执行的指令，处理器采用分支预测逻辑来猜测每条跳转指令是否会执行，如果猜测错了会导致性能降低::
### 过程
**IA32用程序栈来支持过程的调用，栈用来传递过程参数、存储返回信息，保存寄存器以及用于本地存储**
过程的机制:
1. 传递控制:程序计数器
2. 传递数据:参数和返回值
3. 分配和释放内存
当过程需要的存储空间超过寄存器存放的大小的时候，就会在栈(运行时栈)上分配空间，(栈帧)
::支持的指令:call leave ret::
#### 转移控制
通过call指令实现，call指令的效果是将返回地址入栈，并跳转到被调用过程额起始处
#### 栈上的局部存储:
局部数据存放在内存中的情况:
1. 寄存器不足够存放所有本地数据
2. 对一个局部变量使用地址运算符&，因此必须能够为他产生一个地址
3. 某些局部变量是数组或者结构
### 数组
- [ ] 数组变量都指向了数组的开始地址位置
IA32存储器引用指令利用伸缩因子简化了数组的访问:movl 
#### 指针运算
c语言允许对指针进行运算p+i的值为xp+L*i,其中L为p指向数据类型的大小
::expr和*&expr是等价的::
### 异类的数据结构
c语言中提供的结构定义 structure union
#### 结构
结构中所有组成部分存放在存储器中连续的位置
**rp->width等价于(*rp).width**
要产生一个指向结构内部的指针，我们只需要将结构的地址加上该字段的偏移量
#### 联合
联合的指针引用的地址都是数据结构的初始地址，一个联合的总大小总是等于最大字段的大小
#### 数据对齐
许多操作系统对基本数据类型的合法地址做了限制，要求某些对象的地址必须是某个值K的倍数
### 在机器级程序中将控制与数据结合起来
#### 理解指针
1. 每个指针都对应一个类型 `int *p`,如果对象类型为T，那么指针的类型为T*，void*是通用类型指针，指针类型是C语言提供的一种抽象
2. 每个指针都有一个值，这个值是某个指定类型对象的地址
3. 指针用&原算法创建，&一般采用leaq指令计算内存引用的地址
4. *操作符用于间接引用一个指针，其结果是一个值，
5. 数组与指针紧密联系，数组名字可以想指针变量一样引用 a[3]与*(a+3)有一样的效果，都需要用对象大小对偏移量进行伸缩
6. 将指针从一种类型强制转换为另一种类型，只改变类型，不改变值，转换的效果是改变指针运算的伸缩
7. 指针也可以指向函数，提供了一个强大的存储和和想代码传递引用的功能 函数指针的值是该函数机器代码表示中的第一条指令的地址
#### 对抗缓冲区溢出
随机化、栈保护、限制内存可执行
> ALSR，地址空间布局随机化，对抗缓冲区溢出攻击  